@startuml

title Bundle Agent Class Diagram

class Node {
	-m_processor : BundleProcessor
	-m_config : Config
	+Node(configFileName : std::string)
	+~Node()
	+restoreBundles(): void
	+reset() : void
	+sendBeacons() : void
	+receiveBeacons() : void
	+cleanNeighbours() : void
	+listenApps() : void
	+processBundles(): void
	+receiveBundles(): void
}

class BundleProcessor {
	-m_config : Config
	-m_bundle : Bundle
	-m_from : std::string
	-m_dispatch: bool
	-m_nextHop: std::vector<std:string>
	-m_discard: bool
	+BundleProcessor(config : Config)
	+~BundleProcessor()
	+process(bundleContainer : BundleContainer)
	-checkDestination(bundle : Bundle):void
	-checkLifetime(bundle : Bundle):void
	-checkForward(bundle : Bundle):void
	-dispatch(bundle : Bundle) : void
	-forward(bundle : Bundle) : void
	-discard(bundle : Bundle) : void
}

class Config {
	-m_configLoader : ConfigLoader
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : int
	-m_discoveryAddress : std::string
	-m_discoveryProt : int
	-m_discoveryPeriod : int
	-m_neighbourExpirationTime : int
	-m_neighbourCleanerTime : int
	-m_logFileName : std::string
	-m_logLevel : int
	-{static} NODEID : std::string
	-{static} NODEADDRESS : std::string
	-{static} NODEPORT : int
	-{static} DISCOVERYADDRESS : std::string
	-{static} DISCOVERYPORT : int
	-{static} DISCOVERYPERIOD : int
	-{static} NEIGHBOUREXPIRATIONTIME : int
	-{static} NEIGHBOURCLEANERTIME : int
	-{static} LOGFILENAME : std::string
	-{static} LOGLEVEL : int
	+Config(configFileName : std::string)
	+Config()
	+~Config()
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : int
	+getDiscoveryAddress() : std::string
	+getDiscoveryPort() : int
	+getDiscoveryPeriod(): int
	+getNeighbourExpirationTime():int
	+getNeighbourCLeanerTime():int
	+getLogFileName() : std::string
	+getLogLevel():int
}

class ConfigLoader {
	-m_reader : INIReader
	+load(ConfigFile : std::string ) : void
	+ConfigLoader()
	+~ConfigLoader()
}

class BundleContainer {
	- m_bundle : Bundle
	- m_from : std::string
	+ BundleContainer(bundle : Bundle, from : std::string)
	+ getBundle() : Bundle
	+ getFrom() : std::string
}

class BundleQueue << (S,#FF7700) Singleton >>{
	- {static} m_instance : BundleQueue*
	- m_bundles : std::vector<BundleContainer>
	- BundleQueue()
	+ ~BundleQueue()
	+ dequeue(): BundleContainer
	+ enqueue(bundle : BundleContainer) : void
}
note top: Perhaps vector is \nnot the best option \nfor m_bundles

class ListeningAppsTable << (S,#FF7700) Singleton >> {
	- {static} m_instance : ListeningAppsTable*
	- m_listeningApps : std::map<std::string,Socket>
	- ListeningAppsTable()
	+ ~ListeningAppsTable()
	+ start(std::string,Socket): void
	+ stop(std::string) : void
	+ getInfo(std::string) : Socket
}
note left: Review value type for the m_listeningApps map.

Node --> "<i>m_config</i>" Config
BundleProcessor --> "<i>m_config</i>" Config
BundleProcessor ..> BundleQueue : <i>uses</i>
Config --> "<i>m_configLoader</i>" ConfigLoader 
BundleQueue --> "0..n\n<i>m_bundles</i>" BundleContainer
Node ..> BundleQueue : <i>uses</i>
Node --> "<i>m_processor</i>" BundleProcessor
Node ..> ListeningAppsTable : <i>uses</i>
BundleProcessor ..> ListeningAppsTable : <i>uses</i>

footer
	This diagram could be completed with the content of Neighbour Discovery Class Diagram and Bundle Class Diagram.
end footer






title Bundle Class Diagram

class Bundle {
	-m_raw : std::string
	-m_primaryBlock : PrimaryBlock*
	-m_payloadBlock : PayloadBlock*
	-m_blocks : std::vector<Block *>
	+Bundle(rawData : std::string)
	+Bundle(source : std::string, destination : std::string, payload : std::string)
	+~Bundle()
	+getRaw() : std::string
	+toRaw() : std::string
	+getPrimaryBlock() : PrimaryBlock*
	+getPayloadBlock() : PayloadBlock*
	+getBlocks() : std::vector<Block *>
	+addBlock(newBlock : CanonicalBlock*) : void
	+getId() : std::string
}

abstract class Block {
	#m_raw : std::string
	+Block()
	+~Block()
	+{abstract}toRaw() : std::string
	+getRaw() : std::string
	+getLength() : size_t
}

class CanonicalBlock {
	#m_blockType : uint8_t
	-m_procFlags : bitset<7>
	#m_bodyDataIndex : int
	+CanonicalBlock(rawData:std::string)
	+~CanonicalBlock()
	+toRaw() : std::string
	+getBlockType() : uint8_t
	+setProcFlags(procFlag : BlockControlFlags) : void
	+unsetProcFlags(procFlag : BlockControlFlags) : void
	+checkProcFlags(procFlag : BlockControlFlags) : bool
	#initFromRaw(rawData : std::string) : void
}

class MetadataExtensionBlock {
	#m_metadataType : uint8_t
	#m_metadata : std::string
	+MetadataExtensionBlock(rawData : std::string)
	+MetadataExtensionBlock(metadataType : uint8_t, metadata : std::string)
	+~MetadataExtensionBlock()
	+toRaw() : std::string
	+getMetadataType() : uint8_t
	+getMetadata() : std::string
}

class PayloadBlock {
	-m_payload : std::string
	+PayloadBlock(data : std::string, isRaw : bool)
	+~PayloadBlock()
	+toRaw() : std::string
	+getPayload() : std::string
}


class PrimaryBlock {
	-m_procFlags : bitset<21>
	-m_destination : std::string
	-m_source : std::string
	-m_reportTo : std::string
	-m_custodian : std::string
	-m_creationTimestamp : uint64_t
	-m_creationTimestampSeqNumber : uint64_t
	-m_lifetime : uint64_t
	+PrimaryBlock(rawData : std::string)
	+PrimaryBlock(source : std::string, destination : std::string, timestamp : uint64_t, seqNumber : uint64_t)
	+~PrimaryBlock()
	+setPrimaryProcFlag(procFlag : PrimaryBlockControlFlags) : void
	+unsetPrimaryProcFlag(procFlag : PrimaryBlockControlFlags) : void
	+checkPrimaryProcFlag(procFlag : PrimaryBlockControlFlags) : bool
	+toRaw() : std::string
	+getDestination() : std::string
	+getSource() : std::string
	+getReportTo() : std::string
	+getCustodian() : std::string
	+getCreationTimestamp() : uint64_t
	+getCreationTimestampSeqNumber() : uint64_t
	+getLifetime() : uint64_t
	+setReportTo(reportTo : std::string) : void
	+setCustodian(custodian : std::string) : void
	+setLifetime(lifetime : uint64_t) : void
}

enum BlockControlFlags {
	REPLICATE_FRAGMENT : 0
	TRANSMIT_STATUS_REPORT : 1
	DELETE_BUNDLE : 2
	LAST_BLOCK : 3
	DISCARD_BLOCK : 4
	BLOCK_NOT_PROCESSED : 5
	EID_FIELD : 6
}

enum PrimaryBlockControlFlags {
	IS_FRAGMENT : 0
	IS_ADMINISTRATIVE_RECORD : 1
	NOT_FRAGMENTED : 2
	CUSTODY_TRANSFER : 3
	DESTINATION_SINGLETON : 4
	ACKNOWLEDGEMENT_REQUESTED : 5
	PRIORITY_BULK : 21
	PRIORITY_NORMAL : 22
	PRIOTIRY_EXPEDITED : 23
	REQUEST_RECEPTION : 14
	REQUEST_CUSTODY_ACCEPT : 15
	REQUEST_FORWARDING : 16
	REQUEST_DELIVERY : 17
	REQUEST_DELETION : 18
}

enum BlockTypes {
	PAYLOAD_BLOCK : 1
	METADATA_EXTENSION_BLOCK : 8
}

class TimestampManager << (S,#FF7700) Singleton >> {
	-{static}m_instance : TimestampManager*
	-m_lastTimestamp : uint64_t
	-m_lastSeqNum : uint64_t
	-TimestampManager()
	+~TimestampManager()
	+{static}getInstance() : TimestampManager*
	+getTimestamp() : std::pair<uint64_t, uint64_t>
}

class SDNV {
	SDNV::encode(value : uint64_t) : std::string
	SDNV::decode(encodedValue : std::string) : uint64_t
	SDNV::getLength(value : uint64_t) : size_t
	SDNV::getLenght(encodedValue : std::string) : size_t
}
hide SDNV circle

Block <|-- PrimaryBlock
Block <|-- CanonicalBlock
CanonicalBlock <|-- MetadataExtensionBlock
CanonicalBlock <|-- PayloadBlock
Bundle --> "<i>m_primaryBlock</i>" PrimaryBlock
Bundle --> "<i>m_payloadBlock</i>" PayloadBlock
Bundle --> "1..n\n<i>m_blocks</i>" Block






title Neighbour Discovery Class Diagram



class Neighbour {
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : uint16_t
	-m_lastActivity : time_point
	+Neighbour(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t)
	+~Neighbour()
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : uint16_t
	+getElapsedActivityTime() : int
	+update(nodeAddress : std::string, nodePort : uint16_t) : void
	+operator==(neighbour : Neighbour) : bool
}

class NeighbourTable << (S,#FF7700) Singleton >> {
 	-{static} m_instance : NeighbourTable*
 	-m_neighbours : std::map<std::string, shared_ptr<Neighbour>>
 	-mutex : std::mutex
	-NeighbourTable()
	+~NeighbourTable()
	+update(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t) : void
	+cleanNeighbours(expirationTime: int) : void
	+getInstance() : {static} NeighbourTable*
	+getNeighbours() : std::vector<std::string*>
	+getNeighbour(nodeId : std::string ) : Neighbour
}

class NeighbourDiscovery {
}

class Beacon {
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : uint16_t
	-m_raw: std::string
	+{static} MAX_BEACON_SIZE = 1050 : int
	+Beacon(rawData : std::string)
	+Beacon(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t
	+~Beacon()
	+getRaw() : std::string
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : uint16_t
}

Node ..> Beacon : <i>uses</i>
NeighbourTable --> "0..n\n<i>m_neighbours</i>" Neighbour
Node ..> NeighbourTable : <i>uses</i>

footer
	The whole definition of NeighbourDiscovery class is available in Bundle Agent Class Diagram.
end footer


BundleContainer --> "m_bundle" Bundle
@enduml