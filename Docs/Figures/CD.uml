@startuml

title ADTNPlus Node Class Diagram

class Node {
	-m_config : Config
	-m_neighbourTable : NeighbourTable
	-m_listeningAppsTable : ListeningAppsTable
	-m_bundleQueue : BundleQueue
	+Node(configFileName : std::string)
	+~Node()
	+restoreBundles(): void
	+reset() : void
	+start() : void
	+stop() : void
}

abstract class NeighbourDiscovery {
	+{static}sendBeacons(config : Config) : void
	+{static}receiveBeacons(config : Config, neighbourTable : NeighbourTable) : void
	+{static}cleanNeighbours(config : Config, neighbourTable : NeighbourTable) : void
}

abstract class AppListener {
	+{static}listenApps(config : Config, listeningAppsTable : ListeningAppsTable) : void
	+{static}cleanApps(config : Config, listeningAppsTable : ListeningAppsTable) : void
}

abstract class BundleProcessor {
	+BundleProcessor(config : Config, bundleQueue : BundleQueue, listeningAppsTable : ListeningAppsTable, neighbourTable : NeighbourTable)
	+~BundleProcessor()
	+processBundles() : void
	+{abstract}receiveBundles(config : Config, bundleQueue : BundleQueue): void
	-{abstract}processBundle(bundleContainer : BundleContainer): void
}

class BasicFramework {
	#m_config : Config
	#m_bundleQueue : BundleQueue
	#m_listeningAppsTable : ListeningAppsTable
	#m_neighbourTable : NeighbourTable
	
	#m_bundleContainer : BundleContainerWithFrom
	#m_dispatch: bool
	#m_nextHop: std::vector<std:string>
	#m_discard: bool
	
	+BasicFramework(config : Config, bundleQueue : BundleQueue, listeningAppsTable : ListeningAppsTable, neighbourTable : NeighbourTable)
	+~BasicFramework()
	+receiveBundles(config : Config, bundleQueue : BundleQueue): void
	-processBundle(bundleContainer : BundleContainer)
	
	#checkDestination():void
	#checkLifetime():void
	#checkForward():void
	-dispatch() : void
	-forward() : void
	-discard() : void
}

class BundleContainer {
	- m_bundle : Bundle
	+ BundleContainer(bundle : Bundle)
	+ getBundle() : Bundle
}

class BundleContainerWithFrom {
	- m_from : std::string
	+ BundleContainerWithFrom(bundle : Bundle, from : std::string)
	+ getFrom() : std::string
}

class BundleQueue {
	- m_bundles : std::vector<BundleContainer>
	+ BundleQueue()
	+ ~BundleQueue()
	+ dequeue(): BundleContainer
	+ enqueue(bundle : BundleContainer) : void
}

class ListeningAppsTable {
	- m_listeningApps : std::map<std::string,std::string>
	+ ListeningAppsTable()
	+ ~ListeningAppsTable()
	+ start(appId : std::string, info : std::string): void
	+ stop(appId : std::string) : void
	+ getInfo(appId : std::string) : std::string
}

class Config {
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : int
	-m_discoveryAddress : std::string
	-m_discoveryProt : int
	-m_discoveryPeriod : int
	-m_neighbourExpirationTime : int
	-m_neighbourCleanerTime : int
	-m_logFileName : std::string
	-m_logLevel : int
	-{static} NODEID : std::string
	-{static} NODEADDRESS : std::string
	-{static} NODEPORT : int
	-{static} DISCOVERYADDRESS : std::string
	-{static} DISCOVERYPORT : int
	-{static} DISCOVERYPERIOD : int
	-{static} NEIGHBOUREXPIRATIONTIME : int
	-{static} NEIGHBOURCLEANERTIME : int
	-{static} LOGFILENAME : std::string
	-{static} LOGLEVEL : int
	+Config()
	+Config(configFileName : std::string)
	+~Config()
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : int
	+getDiscoveryAddress() : std::string
	+getDiscoveryPort() : int
	+getDiscoveryPeriod(): int
	+getNeighbourExpirationTime():int
	+getNeighbourCLeanerTime():int
	+getLogFileName() : std::string
	+getLogLevel():int
}

class ConfigLoader {
	-m_reader : INIReader
	+load(configFileName : std::string ) : void
	+ConfigLoader()
	+~ConfigLoader()
}

Config ..> ConfigLoader : <i>uses</i> 
BundleQueue --> "0..n\n<i>m_bundles</i>" BundleContainer
Node ..> BundleProcessor : <i>uses</i>










class TimestampManager << (S,#FF7700) Singleton >> {
	-{static}m_instance : TimestampManager*
	-m_lastTimestamp : uint64_t
	-m_lastSeqNum : uint64_t
	-TimestampManager()
	+~TimestampManager()
	+{static}getInstance() : TimestampManager*
	+getTimestamp() : std::pair<uint64_t, uint64_t>
}










class Neighbour {
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : uint16_t
	-m_lastActivity : time_point
	+Neighbour(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t)
	+~Neighbour()
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : uint16_t
	+getElapsedActivityTime() : int
	+update(nodeAddress : std::string, nodePort : uint16_t) : void
	+operator==(neighbour : Neighbour) : bool
}

class NeighbourTable {
 	-m_neighbours : std::map<std::string, shared_ptr<Neighbour>>
 	-mutex : std::mutex
	+NeighbourTable()
	+~NeighbourTable()
	+update(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t) : void
	+cleanNeighbours(expirationTime: int) : void
	+getNeighbours() : std::vector<std::string*>
	+getNeighbour(nodeId : std::string ) : Neighbour
}

class Beacon {
	-m_nodeId : std::string
	-m_nodeAddress : std::string
	-m_nodePort : uint16_t
	-m_raw: std::string
	+{static} MAX_BEACON_SIZE = 1050 : int
	+Beacon(rawData : std::string)
	+Beacon(nodeId : std::string, nodeAddress : std::string, nodePort : uint16_t
	+~Beacon()
	+getRaw() : std::string
	+getNodeId() : std::string
	+getNodeAddress() : std::string
	+getNodePort() : uint16_t
}

NeighbourTable --> "0..n\n<i>m_neighbours</i>" Neighbour

Node --> "<i>m_config</i>" Config
Node --> "<i>m_neighbourTable</i>" NeighbourTable
Node --> "<i>m_listeningAppsTable</i>" ListeningAppsTable
Node ..> NeighbourDiscovery : <i>uses</i>
Node ..> AppListener : <i>uses</i>
NeighbourDiscovery ..> Beacon : <i>uses</i>
Node --> "<i>m_bundleQueue</i>" BundleQueue
BundleContainer <|-- BundleContainerWithFrom
BundleProcessor <|-- BasicFramework
BasicFramework --> BundleContainerWithFrom
@enduml